# M2b Design -- Templates, Auto-Layout, Export Formats

**Date:** 2026-02-20
**Status:** Draft (pending user approval)
**Scope:** 3 new MCP tools (apply_template, auto_layout, export with SVG/PDF), template engine, layout engine

---

## TL;DR

M2b adds three high-value features to MockupMCP: (1) **templates** -- one tool call fills a screen with a full layout (login, dashboard, settings, list, form, profile, onboarding), (2) **auto-layout** -- repositions existing elements in vertical/horizontal/grid flow with spacing/padding, (3) **SVG/PDF export** -- extends the existing export tool to support `format: png|svg|pdf`. No new dependencies needed (Puppeteer already supports PDF; SVG is serialized from the same HTML). `generate_screen` is deferred -- Claude Code already composes screens effectively by calling templates + add_element. Total: 12 tasks across 2 sprints.

---

## 1. Scope Decision

### Included in M2b

| Feature | Priority | Justification |
|---------|----------|---------------|
| `mockup_apply_template` | P0 | Highest value -- one call creates a complete screen. Reduces Claude's tool calls from 8-15 to 1. |
| `mockup_auto_layout` | P1 | Second highest value -- fixes the manual x/y positioning pain. Makes iterative design practical. |
| SVG/PDF export formats | P2 | Low effort, high utility. Puppeteer already has `page.pdf()`. SVG via `outerHTML` serialization. |

### Deferred to M2c or M3

| Feature | Reason to Defer |
|---------|----------------|
| `mockup_generate_screen` (NLP) | Claude Code already composes screens well by calling existing tools. Server-side NLP generation would duplicate LLM reasoning that Claude already does. If needed later, it is just a thin wrapper: parse description -> call apply_template + add_element internally. |
| WebSocket preview | Polling works, 2s latency is acceptable. WebSocket adds connection state management. Low ROI vs. effort. |
| More styles (hand-drawn, flat, blueprint) | Separate milestone -- each style is ~900 LOC of CSS. Not blocking any features. |
| `mockup_to_code` | Phase 3 feature per PRD. Needs design system mapping research. |

---

## 2. Feature Designs

### 2.1 mockup_apply_template

#### What
An MCP tool that populates a screen with a predefined set of elements matching a common UI pattern. The tool clears existing elements on the screen (or creates a new screen) and adds the template's elements.

#### Why
Creating a login screen manually requires ~8 tool calls (add_element for navbar, title, email input, password input, button, forgot link, etc.). With templates, it is 1 call. This is the single biggest UX improvement for Claude Code users.

#### How

**Template definition format** -- each template is a JS module exporting a function:

```javascript
// src/renderer/templates/login.js
export function generate(screenWidth, screenHeight, style) {
  return [
    { type: 'navbar', x: 0, y: 0, width: screenWidth, height: 56, z_index: 10, properties: { title: 'Sign In', leftIcon: 'arrow-left' } },
    { type: 'input', x: 24, y: 120, width: screenWidth - 48, height: 56, z_index: 0, properties: { label: 'Email', placeholder: 'email@example.com', type: 'email' } },
    // ... more elements
  ];
}
```

Templates return an array of element descriptors (same shape as what `addElement` stores, minus the `id`). IDs are generated by the storage layer when elements are added.

**Template registry** -- explicit imports, same pattern as component registry:

```javascript
// src/renderer/templates/index.js
import * as login from './login.js';
import * as dashboard from './dashboard.js';
// ...
const templates = { login, dashboard, settings, list, form, profile, onboarding };

export function getTemplate(name) { return templates[name] || null; }
export function getAvailableTemplates() { return Object.keys(templates); }
```

**Files:**
- Create: `src/renderer/templates/index.js` -- template registry
- Create: `src/renderer/templates/login.js`
- Create: `src/renderer/templates/dashboard.js`
- Create: `src/renderer/templates/settings.js`
- Create: `src/renderer/templates/list.js`
- Create: `src/renderer/templates/form.js`
- Create: `src/renderer/templates/profile.js`
- Create: `src/renderer/templates/onboarding.js`
- Create: `src/mcp/tools/template-tools.js` -- MCP tool registration
- Modify: `src/mcp/tools/index.js` -- register template tools
- Modify: `src/storage/project-store.js` -- add `applyTemplate` method (bulk add elements)

#### API -- MCP Tool Signature

```javascript
server.tool(
  'mockup_apply_template',
  'Apply a preset template to a screen. Replaces all existing elements. Templates: login, dashboard, settings, list, form, profile, onboarding',
  {
    project_id: z.string().describe('Project ID'),
    screen_id: z.string().describe('Screen ID to apply template to'),
    template: z.enum(['login', 'dashboard', 'settings', 'list', 'form', 'profile', 'onboarding'])
      .describe('Template name'),
    clear: z.boolean().optional().default(true)
      .describe('Whether to clear existing elements before applying (default: true)'),
  },
  async ({ project_id, screen_id, template, clear }) => { ... }
);
```

**Returns:** the full screen object with all generated elements (so Claude can immediately see element IDs for follow-up edits).

#### Data Model Changes

**Storage: `ProjectStore.applyTemplate(projectId, screenId, elements, clear)`**

```javascript
async applyTemplate(projectId, screenId, elements, clear = true) {
  this._validateId(screenId);
  const project = await this.getProject(projectId);
  const screen = this._findScreen(project, screenId);

  if (clear) {
    screen.elements = [];
  }

  for (const el of elements) {
    screen.elements.push({
      ...el,
      id: generateId('el'),
    });
  }

  await this._save(project);
  return screen;
}
```

No schema changes needed -- elements have the same shape. Templates just automate the creation of multiple elements at once.

#### Template Specifications

| Template | Elements | Description |
|----------|----------|-------------|
| `login` | navbar, text(title), input(email), input(password), button(sign in), text(forgot password), text(or sign up) | Classic login screen |
| `dashboard` | header, search_bar, 3x card, data_table, tabbar | Dashboard with stats cards and data |
| `settings` | navbar, avatar, 5x list items with toggle/chevron | iOS/Android-style settings page |
| `list` | navbar, search_bar, 5x card(list items), tabbar | Scrollable content list |
| `form` | navbar, text(title), 4x input fields, select, textarea, button(submit) | Multi-field form |
| `profile` | navbar, avatar(large), text(name), text(bio), 3x stat badge, button(edit), list(recent) | User profile page |
| `onboarding` | image(illustration placeholder), text(title), text(description), progress(dots), button(next), text(skip) | Onboarding/welcome slide |

Each template receives `(screenWidth, screenHeight, style)` and adapts positions/sizes to the viewport. Mobile (393x852) is the primary target; templates use relative positioning where practical (e.g., `x: 24`, `width: screenWidth - 48` for standard padding).

---

### 2.2 mockup_auto_layout

#### What
An MCP tool that repositions existing elements on a screen according to a layout algorithm (vertical stack, horizontal row, or grid), with configurable spacing and padding.

#### Why
Manually calculating x/y coordinates for 5-10 elements is tedious and error-prone. Auto-layout lets Claude add elements with approximate positions, then call one tool to align them properly.

#### How

**Layout engine** -- pure function, no state:

```javascript
// src/renderer/layout.js
export function autoLayout(elements, screenWidth, screenHeight, options) {
  const { direction, spacing, padding, align } = {
    direction: 'vertical',
    spacing: 16,
    padding: { top: 16, right: 16, bottom: 16, left: 16 },
    align: 'stretch',
    ...options,
  };
  // Returns new array with updated x, y, width, height
}
```

**Layout modes:**

1. **vertical** -- stack elements top-to-bottom. Each element gets `x: padding.left`, `y: running offset`, `width: screenWidth - padding.left - padding.right` (if align=stretch). Height preserved.
2. **horizontal** -- elements left-to-right in a row. Width preserved, y centered. Wraps not supported (YAGNI).
3. **grid** -- elements arranged in columns x rows grid. `columns` param (default: 2). Even distribution.

**Important constraint:** Auto-layout repositions ALL elements on the screen (or a subset if `element_ids` provided). It does NOT modify element properties -- only x, y, width (for stretch), height (for grid). This means navbar at y=0 would get moved. Solution: respect `z_index` -- elements with `z_index >= 10` are treated as "pinned" and excluded from layout flow (navbar, tabbar are created at z_index 10 by convention).

**Files:**
- Create: `src/renderer/layout.js` -- layout engine (pure function)
- Create: `src/mcp/tools/layout-tools.js` -- MCP tool
- Modify: `src/mcp/tools/index.js` -- register layout tools
- Modify: `src/storage/project-store.js` -- add `bulkMoveElements` method

#### API -- MCP Tool Signature

```javascript
server.tool(
  'mockup_auto_layout',
  'Automatically reposition elements on a screen using vertical, horizontal, or grid layout. Elements with z_index >= 10 (nav bars) are excluded from layout.',
  {
    project_id: z.string().describe('Project ID'),
    screen_id: z.string().describe('Screen ID'),
    direction: z.enum(['vertical', 'horizontal', 'grid'])
      .describe('Layout direction'),
    spacing: z.number().optional().default(16)
      .describe('Space between elements in pixels (default: 16)'),
    padding: z.number().optional().default(16)
      .describe('Padding from screen edges in pixels (default: 16)'),
    columns: z.number().optional().default(2)
      .describe('Number of columns for grid layout (default: 2, ignored for vertical/horizontal)'),
    align: z.enum(['start', 'center', 'stretch']).optional().default('stretch')
      .describe('Cross-axis alignment: start (left/top), center, stretch (full width/height)'),
    element_ids: z.array(z.string()).optional()
      .describe('Specific element IDs to include in layout (default: all non-pinned elements)'),
    start_y: z.number().optional()
      .describe('Y offset to start layout from (useful when navbar occupies top area, e.g. start_y: 56)'),
  },
  async ({ project_id, screen_id, direction, spacing, padding, columns, align, element_ids, start_y }) => { ... }
);
```

**Returns:** the updated screen with all elements (including their new positions).

#### Data Model Changes

**Storage: `ProjectStore.bulkMoveElements(projectId, screenId, updates)`**

```javascript
async bulkMoveElements(projectId, screenId, updates) {
  // updates = [{ id, x, y, width, height }, ...]
  this._validateId(screenId);
  const project = await this.getProject(projectId);
  const screen = this._findScreen(project, screenId);

  for (const update of updates) {
    const el = screen.elements.find(e => e.id === update.id);
    if (!el) continue;
    if (update.x !== undefined) el.x = update.x;
    if (update.y !== undefined) el.y = update.y;
    if (update.width !== undefined) el.width = update.width;
    if (update.height !== undefined) el.height = update.height;
  }

  await this._save(project);
  return screen;
}
```

---

### 2.3 SVG/PDF Export

#### What
Extend the existing `mockup_export` tool to support `format: png|svg|pdf` in addition to the current PNG-only export.

#### Why
SVG gives vector output for scaling/editing. PDF is needed for sharing mockups in documents. Both are trivial to add since Puppeteer supports `page.pdf()` natively, and SVG can be extracted from the rendered HTML page via `page.evaluate(() => document.querySelector('.screen').outerHTML)` + wrapping in SVG foreignObject.

#### How

**PNG** (existing) -- `page.screenshot({ type: 'png' })`

**PDF** -- `page.pdf({ width, height, printBackground: true, pageRanges: '1' })`. Puppeteer renders the HTML as a PDF page. We set explicit width/height to match the screen dimensions.

**SVG** -- Two approaches:
- **Option A (recommended):** Wrap the full HTML in `<foreignObject>` inside an SVG. This preserves all CSS styling. Output is valid SVG that embeds HTML.
- **Option B:** Convert HTML to pure SVG elements. Complex, lossy, not worth it.

Going with Option A -- it produces an SVG file that renders correctly in browsers, Figma import, and most SVG viewers.

```javascript
function htmlToSvg(html, width, height) {
  // Extract the <style> and <body> content, wrap in foreignObject
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <foreignObject width="100%" height="100%">
    ${html}
  </foreignObject>
</svg>`;
}
```

**Files:**
- Modify: `src/renderer/screenshot.js` -- add `takeScreenshotPdf()`, `htmlToSvg()` functions
- Modify: `src/mcp/tools/export-tools.js` -- add `format` param, dispatch to correct export function
- Modify: `src/storage/project-store.js` -- `saveExport` to handle `.pdf` and `.svg` extensions

#### API Changes

```javascript
server.tool(
  'mockup_export',
  'Export a screen as PNG, SVG, or PDF. Returns the file path and inline content.',
  {
    project_id: z.string().describe('Project ID'),
    screen_id: z.string().describe('Screen ID to export'),
    format: z.enum(['png', 'svg', 'pdf']).optional().default('png')
      .describe('Export format: png (raster), svg (vector), pdf (document). Default: png'),
    scale: z.number().optional().default(2)
      .describe('Scale factor for PNG screenshots (ignored for SVG/PDF). Default: 2x'),
  },
  async ({ project_id, screen_id, format, scale }) => { ... }
);
```

**Returns for each format:**
- **PNG:** `{ type: 'image', data: base64, mimeType: 'image/png' }` (same as current)
- **SVG:** `{ type: 'text', text: svgString }` (inline SVG content)
- **PDF:** `{ type: 'text', text: 'Exported to /data/exports/...' }` + file path (PDF is binary, base64 would be huge)

#### Data Model Changes

Extend `saveExport` to accept a format parameter:

```javascript
async saveExport(projectId, screenId, buffer, format = 'png') {
  this._validateId(projectId);
  this._validateId(screenId);
  const exportDir = join(this.exportsDir, projectId);
  await mkdir(exportDir, { recursive: true });
  const filePath = join(exportDir, `${screenId}.${format}`);
  await writeFile(filePath, buffer);
  return filePath;
}
```

---

## 3. Self-Critique

### Edge Cases and Risks

1. **Template viewport adaptation.** Templates are designed for mobile (393x852). If user creates a desktop project (1440x900) and applies "login" template, elements sized for mobile will look too small/narrow. **Mitigation:** Templates receive screenWidth/screenHeight and calculate positions/sizes relative to screen dimensions. Use percentage-based logic for horizontal centering and a max-width constraint for content areas (e.g., `Math.min(screenWidth - 48, 400)` for form width on desktop).

2. **Auto-layout with empty screen.** If screen has 0 elements, auto-layout is a no-op. This is fine, just return the screen. Need clear error message vs silent success.

3. **Auto-layout element_ids with invalid IDs.** If caller passes element IDs that don't exist, should we throw or ignore? **Decision:** ignore missing IDs and layout only found elements. Log a warning.

4. **SVG foreignObject compatibility.** Some tools (Illustrator, old browsers) don't support foreignObject in SVG. This is acceptable -- the SVG is primarily for browser viewing and Figma import (which does support it). For truly vector SVGs, users would need a custom converter (out of scope).

5. **PDF size.** Puppeteer generates PDFs with pixel-based dimensions. A mobile screen (393x852) becomes a ~4.1x8.9 inch page at 96dpi. This is fine for viewing but may look odd printed. Acceptable for mockup use case.

6. **Template clear=false conflicts.** If user applies a template without clearing, new elements may overlap existing ones. This is by design -- clear defaults to true. Document clearly.

### What Might Be Over-Engineered

1. **`element_ids` param on auto-layout.** Is it needed? Claude could delete elements it doesn't want laid out, then call auto-layout. **Verdict:** Keep it. It is one optional param that prevents destructive operations (delete+re-add). Low cost, high utility.

2. **`align` param on auto-layout.** Start/center/stretch adds complexity. Could simplify to just "stretch" for v1. **Verdict:** Keep start/center/stretch. The layout function is pure -- adding align is ~15 extra lines, and center alignment is critical for form layouts.

3. **`start_y` param on auto-layout.** This exists to skip past a navbar (56px). Could instead use the z_index >= 10 pinning convention. **Verdict:** Keep both. start_y is explicit and predictable. z_index pinning is implicit but handles common cases. They complement each other.

### What's Missing

1. **`mockup_list_templates` tool?** Not strictly needed -- template names are in the tool description. But it would be useful for Claude to discover template details (what elements they create, what the result looks like). **Decision:** Add a simple info tool that returns template names and descriptions. Low effort, helps discoverability.

2. **Template customization.** Templates generate fixed content (e.g., "Sign In" title on login). Claude would need to call update_element to change text. This is fine -- templates provide structure, Claude customizes content. No API change needed.

3. **Export all screens at once.** PRD mentions `mockup_export_all`. Useful but can be deferred -- Claude can loop over screens. If we add it, it is just a thin wrapper. **Decision:** Defer to M2c. Not blocking.

### Dependency Issues

- Templates depend on component registry (they reference component types). If template references a type that doesn't exist, the element will render as `<!-- unknown type -->`. **Risk is zero** because templates are hardcoded and we control both sides.
- Auto-layout depends on elements already existing on screen. No dependency on templates -- they are independent features.
- SVG/PDF export depends on screenshot.js and Puppeteer. Both already exist. No new dependencies.
- No circular dependencies between any features.

### Is The Scope Realistic?

12 tasks for 1-2 implementation sessions:
- Sprint 1 (7 tasks): Template registry + 7 template files + template MCP tool + storage method + tests
- Sprint 2 (5 tasks): Layout engine + layout MCP tool + SVG/PDF export + integration tests + PM updates

This is tighter than M2a (16 tasks) but each task is smaller. Templates are boilerplate-heavy but straightforward. Layout engine is the most algorithmic piece (~100 LOC). SVG/PDF export is minimal changes to existing code.

### Simplification Opportunities

1. **SVG export could be skipped entirely.** PDF + PNG cover most use cases. SVG-via-foreignObject is a niche need. **Verdict:** Keep it. It is ~20 LOC. The effort is trivial.

2. **Reduce template count from 7 to 5.** Profile and onboarding could be deferred. **Verdict:** Keep all 7. They are the same pattern repeated with different element lists. Each template is ~40-60 LOC.

---

## 4. Final Recommendation

### Feature List (Prioritized)

1. **P0: Template system** -- registry + 7 templates + `mockup_apply_template` tool + `mockup_list_templates` tool
2. **P1: Auto-layout** -- layout engine + `mockup_auto_layout` tool
3. **P2: SVG/PDF export** -- extend `mockup_export` with format param

### Estimated Task Count: 12

### Key Architectural Decisions

| Decision | Choice | Reasoning |
|----------|--------|-----------|
| Template format | JS functions returning element arrays | Reuses existing component types. No new schema. Templates are code, not data -- allows viewport-adaptive layouts. |
| Template application | Clear screen + bulk insert | Simpler than merge. Templates define complete screens. Follow-up edits via update_element. |
| Layout engine location | `src/renderer/layout.js` (pure function) | Testable in isolation. No side effects. MCP tool calls it, then persists via store. |
| Z-index pinning convention | Elements with z_index >= 10 excluded from auto-layout | Matches existing convention (navbar/tabbar created at z_index 10). No schema change. |
| SVG approach | HTML wrapped in foreignObject | Preserves all CSS styling. ~20 LOC. Alternative (pure SVG conversion) is orders of magnitude more complex. |
| `generate_screen` deferral | Deferred to M2c/M3 | Claude Code composes screens effectively with templates + add_element. Server-side NLP adds complexity with minimal value. Can revisit if user feedback indicates otherwise. |

### New Tools Summary (M2b total: 3 new, 1 modified)

| Tool | Type | Description |
|------|------|-------------|
| `mockup_apply_template` | NEW | Apply a preset template to a screen |
| `mockup_list_templates` | NEW | List available templates with descriptions |
| `mockup_auto_layout` | NEW | Reposition elements with automatic layout |
| `mockup_export` | MODIFIED | Add `format` param (png/svg/pdf) |

After M2b: **17 MCP tools total** (14 existing + 3 new).

---

## 5. Suggested Task Breakdown

### Sprint 1: Templates (7 tasks)

**Task 1: Template registry + storage method**
- Create `src/renderer/templates/index.js` (registry with getTemplate, getAvailableTemplates)
- Add `ProjectStore.applyTemplate()` method to `src/storage/project-store.js`
- Tests for registry + storage method
- Files: `src/renderer/templates/index.js` (NEW), `src/storage/project-store.js` (MOD), `tests/renderer/templates.test.js` (NEW), `tests/storage/project-store.test.js` (MOD)
- Dependencies: none

**Task 2: Templates -- login, form, onboarding**
- Create `src/renderer/templates/login.js`
- Create `src/renderer/templates/form.js`
- Create `src/renderer/templates/onboarding.js`
- Tests: each template generates correct element count, types, positions adapt to viewport
- Dependencies: Task 1

**Task 3: Templates -- dashboard, list**
- Create `src/renderer/templates/dashboard.js`
- Create `src/renderer/templates/list.js`
- Tests: same pattern as Task 2
- Dependencies: Task 1

**Task 4: Templates -- settings, profile**
- Create `src/renderer/templates/settings.js`
- Create `src/renderer/templates/profile.js`
- Tests: same pattern as Task 2
- Dependencies: Task 1

**Task 5: Template MCP tools**
- Create `src/mcp/tools/template-tools.js` (mockup_apply_template + mockup_list_templates)
- Modify `src/mcp/tools/index.js` (register template tools, update tool count)
- Tests: MCP tool integration (apply template creates correct elements, list returns all templates)
- Dependencies: Tasks 1-4

**Task 6: Template integration tests**
- Test: apply each template to each viewport (mobile/tablet/desktop) -- elements fit within screen bounds
- Test: apply each template under each style (wireframe/material/ios) -- renders via buildScreenHtml without error
- Test: clear=true removes existing elements, clear=false preserves them
- File: `tests/renderer/templates-integration.test.js` (NEW)
- Dependencies: Task 5

**Task 7: Sprint 1 commit + test run**
- Run all tests (existing 321 + new ~60 = ~380)
- Fix any failures
- Commit sprint 1
- Dependencies: Tasks 1-6

### Sprint 2: Auto-Layout + Export (5 tasks)

**Task 8: Layout engine**
- Create `src/renderer/layout.js` -- pure function: autoLayout(elements, screenWidth, screenHeight, options)
- Implement vertical, horizontal, grid modes
- z_index >= 10 exclusion, start_y offset, align modes
- Tests: unit tests for each layout mode, edge cases (0 elements, 1 element, pinned elements)
- File: `src/renderer/layout.js` (NEW), `tests/renderer/layout.test.js` (NEW)
- Dependencies: none (independent of templates)

**Task 9: Auto-layout MCP tool**
- Create `src/mcp/tools/layout-tools.js`
- Add `ProjectStore.bulkMoveElements()` to `src/storage/project-store.js`
- Modify `src/mcp/tools/index.js` (register layout tools)
- Tests: MCP tool integration
- Dependencies: Task 8

**Task 10: SVG/PDF export**
- Add `takePdfExport(html, width, height)` to `src/renderer/screenshot.js`
- Add `htmlToSvg(html, width, height)` to `src/renderer/screenshot.js`
- Modify `src/mcp/tools/export-tools.js` -- add `format` param, dispatch logic
- Modify `src/storage/project-store.js` -- `saveExport` accepts format param
- Tests: SVG output contains foreignObject + screen content, PDF is valid buffer
- Dependencies: none

**Task 11: Full integration tests**
- Test: auto-layout after apply_template (common workflow)
- Test: export template-generated screens in all 3 formats
- Test: template + layout + export end-to-end flow
- File: `tests/integration/m2b-integration.test.js` (NEW)
- Dependencies: Tasks 7, 9, 10

**Task 12: PM updates + final commit**
- Update `PM/milestones.md`
- Create `PM/tasks/M2b.md`
- Run full test suite, verify all pass
- Commit
- Dependencies: Task 11

### Dependency Graph

```
Task 1 (registry+storage)
  ├── Task 2 (login, form, onboarding)
  ├── Task 3 (dashboard, list)         ── can run parallel with 2, 4
  └── Task 4 (settings, profile)
        └── Task 5 (MCP tools)
              └── Task 6 (integration tests)
                    └── Task 7 (sprint 1 commit)

Task 8 (layout engine)     ── parallel with Sprint 1
  └── Task 9 (layout MCP tool)

Task 10 (SVG/PDF export)   ── parallel with Sprint 1

Tasks 7, 9, 10
  └── Task 11 (full integration)
        └── Task 12 (PM + commit)
```

### Parallelization Opportunities

- Sprint 1: Tasks 2, 3, 4 are independent (different template files, no overlap)
- Sprint 2: Tasks 8, 9 (layout) and Task 10 (export) are fully independent
- Between sprints: Task 8 can start before Sprint 1 finishes (no file overlap)

### Estimated Output

| Metric | Count |
|--------|-------|
| New files | ~14 (7 templates, 2 registries, 2 MCP tools, 2 test files, 1 layout engine) |
| Modified files | ~4 (project-store.js, export-tools.js, screenshot.js, tools/index.js) |
| New tests | ~70-80 |
| New LOC | ~1200-1500 (templates are dense but repetitive) |
| Total tools after M2b | 17 |
